//! Type definitions for the Merkle tree primitives used in this crate.

use arrayref::mut_array_refs;
pub use rs_merkle::{MerkleProof, MerkleTree};
use sha3::{Digest, Keccak256};
#[cfg(any(test, feature = "test-fixtures", feature = "solana"))]
use solana_program::keccak::hashv;

/// Merkle Tree implementation that uses Solana's `hashv` syscall to merge
/// its nodes.
#[cfg(any(test, feature = "test-fixtures", feature = "solana"))]
#[derive(Copy, Clone)]
pub struct SolanaSyscallHasher;

#[cfg(any(test, feature = "test-fixtures", feature = "solana"))]
impl rs_merkle::Hasher for SolanaSyscallHasher {
    type Hash = [u8; 32];

    fn hash(data: &[u8]) -> Self::Hash {
        hashv(&[data]).to_bytes()
    }

    fn concat_and_hash(left: &Self::Hash, right: Option<&Self::Hash>) -> Self::Hash {
        concat_and_hash(left, right, Self::hash)
    }
}

#[derive(Copy, Clone)]
pub struct NativeHasher;

impl rs_merkle::Hasher for NativeHasher {
    type Hash = [u8; 32];

    fn hash(data: &[u8]) -> Self::Hash {
        let mut hasher = Keccak256::default();
        hasher.update(data);
        hasher.finalize().into()
    }

    fn concat_and_hash(left: &Self::Hash, right: Option<&Self::Hash>) -> Self::Hash {
        concat_and_hash(left, right, Self::hash)
    }
}

/// This implementation deviates from the default for several reasons:
/// 1. It prefixes intermediate nodes before hashing to prevent second preimage
///    attacks. This distinguishes leaf nodes from intermediates, blocking
///    attempts to craft alternative trees with the same root hash using
///    malicious hashes.
/// 2. If the left node doesn't have a sibling it is concatenated to itself and
///    then hashed instead of just being propagated to the next level.
/// 3. It uses arrays instead of vectors to avoid heap allocations.
#[inline]
fn concat_and_hash(
    left: &[u8; 32],
    right: Option<&[u8; 32]>,
    hash_fn: fn(&[u8]) -> [u8; 32],
) -> [u8; 32] {
    let mut concatenated: [u8; 65] = [0; 65];
    let (prefix, left_node, right_node) = mut_array_refs![&mut concatenated, 1, 32, 32];
    prefix[0] = 1;
    left_node.copy_from_slice(left);
    right_node.copy_from_slice(right.unwrap_or(left));
    hash_fn(&concatenated)
}

#[cfg(test)]
mod tests {
    use std::array;

    use rs_merkle::Hasher;

    use super::*;
    use crate::test_fixtures::random_bytes;

    /// Tests that the hashing functions of both `SolanaSyscallHasher` and
    /// `DefaultHasher` produce identical results for the same input data.
    #[test]
    fn hash_equivalence_across_impls() {
        let data = random_bytes::<256>();
        assert_eq!(
            SolanaSyscallHasher::hash(&data),
            NativeHasher::hash(&data),
            "Hashes from SolanaSyscallHasher and DefaultHasher should be equal"
        )
    }

    /// Tests that Merkle proofs generated by both `SolanaSyscallHasher` and
    /// `DefaultHasher` are consistent and can be verified between
    /// implementations
    #[test]
    fn proof_equivalence_between_impls() {
        const NUM_LEAVES: usize = 100;
        // Generate a fixed number of random leaves for the Merkle trees
        let leaves: [[u8; 32]; NUM_LEAVES] = array::from_fn(|_| random_bytes());

        // Create Merkle trees using both hasher implementations
        let keccak_tree = MerkleTree::<NativeHasher>::from_leaves(&leaves);
        let solana_tree = MerkleTree::<SolanaSyscallHasher>::from_leaves(&leaves);

        // Both trees should have the same root hash
        let keccak_root = keccak_tree.root().expect("Keccak tree should have a root");
        let solana_root = solana_tree.root().expect("Solana tree should have a root");
        assert_eq!(
            keccak_root, solana_root,
            "Root hashes of both Merkle trees should match"
        );

        // Generate Merkle proofs for each leaf in both trees
        let keccak_proofs: [MerkleProof<_>; NUM_LEAVES] =
            array::from_fn(|idx| keccak_tree.proof(&[idx]));
        let solana_proofs: [MerkleProof<_>; NUM_LEAVES] =
            array::from_fn(|idx| solana_tree.proof(&[idx]));

        // Each corresponding pair of proofs should be identical
        for (idx, (solana_proof, keccak_proof)) in
            solana_proofs.iter().zip(keccak_proofs.iter()).enumerate()
        {
            let sol_proof_bytes = solana_proof.to_bytes();
            let keccak_proof_bytes = keccak_proof.to_bytes();
            assert_eq!(
                sol_proof_bytes, keccak_proof_bytes,
                "Proof bytes for leaf index {} should match between implementations",
                idx
            );
        }

        // Proofs should be valid
        for (idx, leaf) in leaves.iter().enumerate() {
            assert!(
                keccak_proofs[idx].verify(keccak_root, &[idx], &[*leaf], NUM_LEAVES),
                "Keccak Merkle proof should be valid for leaf index {}",
                idx,
            );
            assert!(
                solana_proofs[idx].verify(solana_root, &[idx], &[*leaf], NUM_LEAVES),
                "SolanaSyscall Merkle proof should be valid for leaf index {}",
                idx
            );
        }
    }
}
